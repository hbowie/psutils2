/*
 * Copyright 2012 - 2017 Herb Bowie
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.powersurgepub.psutils2.clubplanner;

	import com.powersurgepub.psutils2.list.*;
	import com.powersurgepub.psutils2.records.*;
	import com.powersurgepub.psutils2.strings.*;
	import com.powersurgepub.psutils2.tags.*;

  import java.io.*;
  import java.util.*;

  import javafx.scene.control.*;
 
/**
 A single event, or other item to be tracked by the club. <p>
 
    This item class definition generated by PSTextMerge using: <p>
 
     template:  item-class.java <p>
     data file: /Users/hbowie/Java/projects/nbproj/clubplanner/javagen/fields.xls

 @author Herb Bowie
 */
public class EventAction
    implements
      // Generated by PSTextMerge using template taggable-implements.java.
      // No taggable fields
            Comparable,
            PSItem
			 {

  private static final RecordDefinition recDef;


  /*
   Following code generated by PSTextMerge using:
 
     template:  variable-definitions.java
     data file: /Users/hbowie/Java/projects/nbproj/clubplanner/javagen/fields.xls
   */
 

  /**
   Is this a numbered list?
   */
  private Boolean numbered = null;
 
  public static final String NUMBERED_FIELD_NAME = "Numbered";
 
  public static final String NUMBERED_COLUMN_NAME = "#?";
 
  public static final String NUMBERED_COMMON_NAME = "numbered";
 
  public static final int NUMBERED_COLUMN_INDEX = 0;
 
  public static final int NUMBERED_COLUMN_WIDTH = 10;
 

  /**
   The person(s) repsponsible to take the indicated action
   */
  private String actionee = null;
 
  public static final String ACTIONEE_FIELD_NAME = "Actionee";
 
  public static final String ACTIONEE_COLUMN_NAME = "Actionee";
 
  public static final String ACTIONEE_COMMON_NAME = "actionee";
 
  public static final int ACTIONEE_COLUMN_INDEX = 1;
 
  public static final int ACTIONEE_COLUMN_WIDTH = 40;
 

  /**
   The action to be taken.
   */
  private String action = null;
 
  public static final String ACTION_FIELD_NAME = "Action";
 
  public static final String ACTION_COLUMN_NAME = "Actionee";
 
  public static final String ACTION_COMMON_NAME = "action";
 
  public static final int ACTION_COLUMN_INDEX = 2;
 
  public static final int ACTION_COLUMN_WIDTH = 40;
 

  public static final int COLUMN_COUNT = 3;


  private boolean modified = false;
 
  private String  diskLocation = "";
 
  private Comparator comparator = new EventActionDefaultComparator();

  /**
   Static initializer.
   */
  static {
    DataDictionary dict = new DataDictionary();
    recDef = new RecordDefinition (dict);
    for (int i = 0; i < COLUMN_COUNT; i++) {
      recDef.addColumn (getColumnName(i));
    }
  }

  /**
   A constructor without any arguments.
   */
  public EventAction() {

  }
 
  /**
   Get the comparator to be used;
   */
  public Comparator getComparator() {
    return comparator;
  }
 
  /**
   Set the comparator to be used.
   */
  public void setComparator (Comparator comparator) {
    this.comparator = comparator;
  }
 
  /**
   Determine if this item has a key that is equal to the passed
   item.

   @param  obj2        The second object to be compared to this one.
   @param  comparator  The comparator to be used to make the comparison.
   @return True if the keys are equal.
   */
  public boolean equals (Object obj2, Comparator comparator) {
    return (this.compareTo (obj2, comparator) == 0);
  }
 
  /**
   Determine if this item has a key that is equal to the passed
   item.

   @param  obj2  The second object to be compared to this one.
   @return True if the keys are equal.
   */
  public boolean equals (Object obj2) {
    return (this.compareTo (obj2) == 0);
  }
 
  /**
   Compare this ClubEvent object to another, using the key field(s) for comparison.
 
   @param The second object to compare to this one.
 
   @return A number less than zero if this object is less than the second,
           a number greater than zero if this object is greater than the second,
           or zero if the two item's keys are equal.
   */
  public int compareTo (Object obj2, Comparator comparator) {
    if (comparator == null) {
      return -1;
    }
    return comparator.compare (this, obj2);
  }
 
  /**
   Compare this ClubEvent object to another, using the key field(s) for comparison.
 
   @param The second object to compare to this one.
 
   @return A number less than zero if this object is less than the second,
           a number greater than zero if this object is greater than the second,
           or zero if the two item's keys are equal.
   */
  public int compareTo (Object obj2) {
    if (comparator == null) {
      return -1;
    }
    return comparator.compare (this, obj2);
  }
 
  public void resetModified() {
    setModified (false);
  }
 
  public void setModified (boolean modified) {
    this.modified = modified;
  }
 
  public boolean isModified() {
    return modified;
  }
 
  /**
   Set the disk location at which this item is stored.
 
   @param diskLocation The path to the disk location at which this item
                       is stored.
  */
  public void setDiskLocation (String diskLocation) {
    this.diskLocation = diskLocation;
  }
 
  /**
   Set the disk location at which this item is stored.
 
   @param diskLocationFile The disk location at which this item is stored.
  */
  public void setDiskLocation (File diskLocationFile) {
    try {
      this.diskLocation = diskLocationFile.getCanonicalPath();
    } catch (java.io.IOException e) {
      this.diskLocation = diskLocationFile.getAbsolutePath();
    }
  }
 
  /**
   Indicate whether the item has a disk location.
 
   @return True if we've got a disk location, false otherwise.
  */
  public boolean hasDiskLocation() {
    return (diskLocation != null
        && diskLocation.length() > 0);
  }
 
  /**
   Return the disk location at which this item is stored.
 
   @return The disk location at which this item is stored.
  */
  public String getDiskLocation () {
    return diskLocation;
  }
 
  /**
   Find a common name (no punctuation, all lower-case) that starts with
   the passed string, if one exists.
 
   @param possibleFieldName The potential field name we're looking for. This
                            will be converted to a common name before it's
                            compared to the common forms of the field names.
 
   @return The index pointing to the first matching common name that was found,
           or -1 if no match was found.
  */
  public static int commonNameStartsWith (String possibleFieldName) {
    int i = 0;
    boolean fieldMatch = false;
    String possibleCommonName = StringUtils.commonName (possibleFieldName);
    while (i < COLUMN_COUNT && (! fieldMatch)) {
      if (getCommonName(i).startsWith(possibleCommonName)) {
        fieldMatch = true;
      } else {
        i++;
      }
    } // end while looking for field name match
    if (fieldMatch) {
      return i;
    } else {
      return -1;
    }
  }

  /**
   Return a record definition for the ClubEvent.
 
   @return A record definition using a new dictionary.
  */
  public static RecordDefinition getRecDef() {
    return recDef;
  }
 
  /**
   Return a standard data rec using the variables belonging to this object.
 
   @return A generic data record.
  */
  public DataRecord getDataRec() {
    DataRecord dataRec = new DataRecord();
    for (int i = 0; i < COLUMN_COUNT; i++) {
      Object columnValue = getColumnValue(i);
      String columnValueStr = "";
      if (columnValue != null) {
        columnValueStr = columnValue.toString();
      }
      DataField nextField = new DataField(recDef, i, columnValueStr);
      nextField.setDataRaw(columnValueStr);
      int dataRecFieldNumber = dataRec.addField(nextField);
      // int dataRecFieldNumber = dataRec.addField(recDef, columnValueStr);
    }
    return dataRec;
  }
 

  /*
   Following code generated by PSTextMerge using:
 
     template:  duplicate.java
     data file: /Users/hbowie/Java/projects/nbproj/clubplanner/javagen/fields.xls
   */
 
  /**
     Duplicates this item, making a deep copy.
   */
  public EventAction duplicate () {
    EventAction newEventAction = new EventAction();
		String numberedStr = new String(getNumberedAsString());
		newEventAction.setNumbered(numberedStr);
		String actioneeStr = new String(getActioneeAsString());
		newEventAction.setActionee(actioneeStr);
		String actionStr = new String(getActionAsString());
		newEventAction.setAction(actionStr);
		return newEventAction;
  }
 
  /**
    Check for a search string within the given Club Event item.
 
    This method generated by PSTextMerge using template find.java.
 
    @param findLower   The search string in all lower case.
    @param findUpper   The search string in all upper case.
 
    @return True if this item contains the search string
            in one of its searchable fields.

   */
  public boolean find (String findLower, String findUpper) {

    boolean found = false;
    int fieldStart = -1;

    return found;
  }

  /**
    Return a string value representing the given item.
 
    This method generated by PSTextMerge using template toString.java.
 
    @return The string by which this item shall be known.

   */
  public String toString() {

    StringBuilder str = new StringBuilder();

    return str.toString();
  }

  /*
   Following code generated by PSTextMerge using:
 
     template:  merge.java
     data file: /Users/hbowie/Java/projects/nbproj/clubplanner/javagen/fields.xls
   */
 
  /**
     Merges the contents of a second item into this one.
   */
  public void merge (EventAction eventAction2) {
    Object obj2;
    String str2;
    obj2 = eventAction2.getNumbered();
    if (obj2 == null) {
      // No value available -- leave current value as-is
    } else {
      str2 = obj2.toString();
      if (str2.equals ("")) {
        // No value available -- leave current value as-is
      } else {
        setNumbered ((Boolean)obj2);
      }
    }
    obj2 = eventAction2.getActionee();
    if (obj2 == null) {
      // No value available -- leave current value as-is
    } else {
      str2 = obj2.toString();
      if (str2.equals ("")) {
        // No value available -- leave current value as-is
      } else {
        setActionee ((String)obj2);
      }
    }
    obj2 = eventAction2.getAction();
    if (obj2 == null) {
      // No value available -- leave current value as-is
    } else {
      str2 = obj2.toString();
      if (str2.equals ("")) {
        // No value available -- leave current value as-is
      } else {
        setAction ((String)obj2);
      }
    }
  }

  /*
   Following code generated by PSTextMerge using:
 
     template:  setColumnValue.java
     data file: /Users/hbowie/Java/projects/nbproj/clubplanner/javagen/fields.xls
   */
 
 
 /**
  Sets the column value indicated by the given column index.
 
  @param columnIndex An integer indicating the desired column whose value is to
                     be set.
  @param columnValue A string representing the value to be set.
  */
  public void setColumnValue (int columnIndex, String columnValue) {
    switch (columnIndex) {
      case NUMBERED_COLUMN_INDEX:
          setNumbered (columnValue);
          break;
      case ACTIONEE_COLUMN_INDEX:
          setActionee (columnValue);
          break;
      case ACTION_COLUMN_INDEX:
          setAction (columnValue);
          break;
    }
  }

  /*
   Following code generated by PSTextMerge using:
 
     template:  getColumnValue.java
     data file: /Users/hbowie/Java/projects/nbproj/clubplanner/javagen/fields.xls
   */
 
  /**
     Returns the value at the given column index.
   */
  public Object getColumnValue (int columnIndex) {
    switch (columnIndex) {
      case NUMBERED_COLUMN_INDEX:
          return numbered;
      case ACTIONEE_COLUMN_INDEX:
          return actionee;
      case ACTION_COLUMN_INDEX:
          return action;
      default: return null;
    }
  }

  /*
   Following code generated by PSTextMerge using:
 
     template:  getColumnName.java
     data file: /Users/hbowie/Java/projects/nbproj/clubplanner/javagen/fields.xls
   */
 
  /**
     Returns the field name for the given column index.
   */
  public static String getColumnName (int columnIndex) {
    switch (columnIndex) {
      case NUMBERED_COLUMN_INDEX:
          return NUMBERED_COLUMN_NAME;
      case ACTIONEE_COLUMN_INDEX:
          return ACTIONEE_COLUMN_NAME;
      case ACTION_COLUMN_INDEX:
          return ACTION_COLUMN_NAME;
      default: return null;
    }
  }

  /*
   Following code generated by PSTextMerge using:
 
     template:  getCommonName.java
     data file: /Users/hbowie/Java/projects/nbproj/clubplanner/javagen/fields.xls
   */
 
  /**
     Returns the common name (all lower case, no word separators)
     for the given column index.
   */
  public static String getCommonName (int columnIndex) {
    switch (columnIndex) {
      case NUMBERED_COLUMN_INDEX:
          return NUMBERED_COMMON_NAME;
      case ACTIONEE_COLUMN_INDEX:
          return ACTIONEE_COMMON_NAME;
      case ACTION_COLUMN_INDEX:
          return ACTION_COMMON_NAME;
      default: return null;
    }
  }

  /*
   Following code generated by PSTextMerge using:
 
     template:  getColumnWidth.java
     data file: /Users/hbowie/Java/projects/nbproj/clubplanner/javagen/fields.xls
   */
 
  /**
     Returns the field name for the given column index.
   */
  public static int getColumnWidth (int columnIndex) {
    switch (columnIndex) {
      case NUMBERED_COLUMN_INDEX:
          return NUMBERED_COLUMN_WIDTH;
      case ACTIONEE_COLUMN_INDEX:
          return ACTIONEE_COLUMN_WIDTH;
      case ACTION_COLUMN_INDEX:
          return ACTION_COLUMN_WIDTH;
      default: return 20;
    }
  }

  /*
   Following code generated by PSTextMerge using:
 
     template:  getColumnClass.java
     data file: /Users/hbowie/Java/projects/nbproj/clubplanner/javagen/fields.xls
   */
 
  /**
     Returns the class of the field at the given column index.
   */
  public static Class getColumnClass (int columnIndex) {
    switch (columnIndex) {
      case NUMBERED_COLUMN_INDEX:
          return Boolean.class;
      case ACTIONEE_COLUMN_INDEX:
          return String.class;
      case ACTION_COLUMN_INDEX:
          return String.class;
      default: return null;
    }
  }

  /*
   Following code generated by PSTextMerge using:
 
     template:  isMarkdownFormat.java
     data file: /Users/hbowie/Java/projects/nbproj/clubplanner/javagen/fields.xls
   */
 
  /**
     Indicates whether the field at the given column index should be in Markdown format.
   */
  public static boolean isMarkdownFormat (int columnIndex) {
    switch (columnIndex) {
      default: return false;
    }
  }

  /*
   Following code generated by PSTextMerge using:
 
     template:  variable-methods.java
     data file: /Users/hbowie/Java/projects/nbproj/clubplanner/javagen/fields.xls
   */
 
 
  /**
     Sets the numbered for this event action.
 
     @param  numbered The numbered for this event action.
   */
  public void setNumbered (Boolean numbered) {
    this.numbered = numbered;
    setModified (true);
  }

  /**
     Sets the numbered for this event action.
 
     @param  numbered The numbered for this event action.
   */
  public void setNumbered (String numbered) {
    this.numbered = new Boolean(numbered);
    setModified (true);
  }

  /**
    Returns the numbered for this event action as a string.
 
    @return The numbered for this event action as a string.
   */
  public String getNumberedAsString () {
    if (hasNumbered()) {
      return getNumbered().toString();
    } else {
      return "";
    }
  }

  /**
    Determines if the numbered for this event action is null.
 
    @return True if the numbered for this event action is not null.
   */
  public boolean hasNumbered () {
    return (numbered != null);
  }

  /**
    Returns the numbered for this event action.
 
    @return The numbered for this event action.
   */
  public Boolean getNumbered () {
    return numbered;
  }
 
  /**
     Sets the actionee for this event action.
 
     @param  actionee The actionee for this event action.
   */
  public void setActionee (String actionee) {
    this.actionee = actionee;
    setModified (true);
  }

  /**
    Returns the actionee for this event action as a string.
 
    @return The actionee for this event action as a string.
   */
  public String getActioneeAsString () {
    if (hasActionee()) {
      return getActionee().toString();
    } else {
      return "";
    }
  }

  /**
    Determines if the actionee for this event action is null.
 
    @return True if the actionee for this event action is not null.
   */
  public boolean hasActionee () {
    return (actionee != null);
  }

  /**
    Determines if the actionee for this event action
    is null or is empty.
 
    @return True if the actionee for this event action
    is not null and not empty.
   */
  public boolean hasActioneeWithData () {
    return (actionee != null && actionee.length() > 0);
  }

  /**
    Returns the actionee for this event action.
 
    @return The actionee for this event action.
   */
  public String getActionee () {
    return actionee;
  }
 
  /**
     Sets the action for this event action.
 
     @param  action The action for this event action.
   */
  public void setAction (String action) {
    this.action = action;
    setModified (true);
  }

  /**
    Returns the action for this event action as a string.
 
    @return The action for this event action as a string.
   */
  public String getActionAsString () {
    if (hasAction()) {
      return getAction().toString();
    } else {
      return "";
    }
  }

  /**
    Determines if the action for this event action is null.
 
    @return True if the action for this event action is not null.
   */
  public boolean hasAction () {
    return (action != null);
  }

  /**
    Determines if the action for this event action
    is null or is empty.
 
    @return True if the action for this event action
    is not null and not empty.
   */
  public boolean hasActionWithData () {
    return (action != null && action.length() > 0);
  }

  /**
    Returns the action for this event action.
 
    @return The action for this event action.
   */
  public String getAction () {
    return action;
  }

  /**
   Return the number of columns.
   */
  public static int getColumnCount() {
    return COLUMN_COUNT;
  }

  /*
   Following code generated by PSTextMerge using:
 
     template:  taggable-methods.java
     data file: /Users/hbowie/Java/projects/nbproj/clubplanner/javagen/fields.xls
   */
 

  /**
   Does this class have a Tags field?
 
   @return True if so, false if not.
   */
  public static boolean isClassTagged() {
    return false;
  }
 
  /**
   Return the tags assigned to this taggable item.
 
   @return The tags assigned.
   */
  public Tags getTags () {
    // No Tags field for this item
    return null;
  }
 
  /**
   Flatten all the tags for this item, separating each level/word into its own
   first-level tag.
   */
  public void flattenTags() {
    // No Tags field for this item
  }

  /**
   Convert the tags to all lower-case letters.
   */
  public void lowerCaseTags (){
    // No Tags field for this item
  }
 
  /**
   Set the first TagsNode occurrence for this Taggable item. This is stored
   in a TagsModel occurrence.

   @param tagsNode The tags node to be stored.
   */
  public void setTagsNode (TreeItem<TagsNodeValue> tagsNode) {
    // No Tags field for this item
  }

  /**
   Return the first TagsNode occurrence for this Taggable item. These nodes
   are stored in a TagsModel occurrence.

   @return The tags node stored.
   */
  public TreeItem<TagsNodeValue> getTagsNode () {
    // No Tags field for this item
    return null;
  }

}
